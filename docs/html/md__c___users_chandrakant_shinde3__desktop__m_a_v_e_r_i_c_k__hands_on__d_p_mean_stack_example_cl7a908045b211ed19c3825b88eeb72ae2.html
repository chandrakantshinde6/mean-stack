<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>end to end lab: Metadata Reflection API</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">end to end lab
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Metadata Reflection API </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><ul>
<li><a href="https://rbuckton.github.io/reflect-metadata">Detailed proposal</a></li>
</ul>
<h1><a class="anchor" id="autotoc_md11701"></a>
Installation</h1>
<div class="fragment"><div class="line">npm install reflect-metadata</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md11702"></a>
Background</h1>
<ul>
<li>Decorators add the ability to augment a class and its members as the class is defined, through a declarative syntax.</li>
<li>Traceur attaches annotations to a static property on the class.</li>
<li>Languages like C# (.NET), and Java support attributes or annotations that add metadata to types, along with a reflective API for reading metadata.</li>
</ul>
<h1><a class="anchor" id="autotoc_md11703"></a>
Goals</h1>
<ul>
<li>A number of use cases (Composition/Dependency Injection, Runtime Type Assertions, Reflection/Mirroring, Testing) want the ability to add additional metadata to a class in a consistent manner.</li>
<li>A consistent approach is needed for various tools and libraries to be able to reason over metadata.</li>
<li>Metadata-producing decorators (nee. "Annotations") need to be generally composable with mutating decorators.</li>
<li>Metadata should be available not only on an object but also through a Proxy, with related traps.</li>
<li>Defining new metadata-producing decorators should not be arduous or over-complex for a developer.</li>
<li>Metadata should be consistent with other language and runtime features of ECMAScript.</li>
</ul>
<h1><a class="anchor" id="autotoc_md11704"></a>
Syntax</h1>
<ul>
<li>Declarative definition of metadata: <div class="fragment"><div class="line">class C {</div>
<div class="line">  @Reflect.metadata(metadataKey, metadataValue)</div>
<div class="line">  method() {</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --></li>
<li>Imperative definition of metadata: <div class="fragment"><div class="line">Reflect.defineMetadata(metadataKey, metadataValue, C.prototype, &quot;method&quot;);</div>
</div><!-- fragment --></li>
<li>Imperative introspection of metadata: <div class="fragment"><div class="line">let obj = new C();</div>
<div class="line">let metadataValue = Reflect.getMetadata(metadataKey, obj, &quot;method&quot;);</div>
</div><!-- fragment --></li>
</ul>
<h1><a class="anchor" id="autotoc_md11705"></a>
Semantics</h1>
<ul>
<li>Object has a new [[Metadata]] internal property that will contain a Map whose keys are property keys (or <b>undefined</b>) and whose values are Maps of metadata keys to metadata values.</li>
<li>Object will have a number of new internal methods for [[DefineOwnMetadata]], [[GetOwnMetadata]], [[HasOwnMetadata]], etc.<ul>
<li>These internal methods can be overridden by a Proxy to support additional traps.</li>
<li>These internal methods will by default call a set of abstract operations to define and read metadata.</li>
</ul>
</li>
<li>The Reflect object will expose the MOP operations to allow imperative access to metadata.</li>
<li>Metadata defined on class declaration <em>C</em> is stored in <em>C</em>.[[Metadata]], with <b>undefined</b> as the key.</li>
<li>Metadata defined on static members of class declaration <em>C</em> are stored in <em>C</em>.[[Metadata]], with the property key as the key.</li>
<li>Metadata defined on instance members of class declaration <em>C</em> are stored in <em>C</em>.prototype.[[Metadata]], with the property key as the key.</li>
</ul>
<h1><a class="anchor" id="autotoc_md11706"></a>
API</h1>
<div class="fragment"><div class="line">// define metadata on an object or property</div>
<div class="line">Reflect.defineMetadata(metadataKey, metadataValue, target);</div>
<div class="line">Reflect.defineMetadata(metadataKey, metadataValue, target, propertyKey);</div>
<div class="line"> </div>
<div class="line">// check for presence of a metadata key on the prototype chain of an object or property</div>
<div class="line">let result = Reflect.hasMetadata(metadataKey, target);</div>
<div class="line">let result = Reflect.hasMetadata(metadataKey, target, propertyKey);</div>
<div class="line"> </div>
<div class="line">// check for presence of an own metadata key of an object or property</div>
<div class="line">let result = Reflect.hasOwnMetadata(metadataKey, target);</div>
<div class="line">let result = Reflect.hasOwnMetadata(metadataKey, target, propertyKey);</div>
<div class="line"> </div>
<div class="line">// get metadata value of a metadata key on the prototype chain of an object or property</div>
<div class="line">let result = Reflect.getMetadata(metadataKey, target);</div>
<div class="line">let result = Reflect.getMetadata(metadataKey, target, propertyKey);</div>
<div class="line"> </div>
<div class="line">// get metadata value of an own metadata key of an object or property</div>
<div class="line">let result = Reflect.getOwnMetadata(metadataKey, target);</div>
<div class="line">let result = Reflect.getOwnMetadata(metadataKey, target, propertyKey);</div>
<div class="line"> </div>
<div class="line">// get all metadata keys on the prototype chain of an object or property</div>
<div class="line">let result = Reflect.getMetadataKeys(target);</div>
<div class="line">let result = Reflect.getMetadataKeys(target, propertyKey);</div>
<div class="line"> </div>
<div class="line">// get all own metadata keys of an object or property</div>
<div class="line">let result = Reflect.getOwnMetadataKeys(target);</div>
<div class="line">let result = Reflect.getOwnMetadataKeys(target, propertyKey);</div>
<div class="line"> </div>
<div class="line">// delete metadata from an object or property</div>
<div class="line">let result = Reflect.deleteMetadata(metadataKey, target);</div>
<div class="line">let result = Reflect.deleteMetadata(metadataKey, target, propertyKey);</div>
<div class="line"> </div>
<div class="line">// apply metadata via a decorator to a constructor</div>
<div class="line">@Reflect.metadata(metadataKey, metadataValue)</div>
<div class="line">class C {</div>
<div class="line">  // apply metadata via a decorator to a method (property)</div>
<div class="line">  @Reflect.metadata(metadataKey, metadataValue)</div>
<div class="line">  method() {</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md11707"></a>
Alternatives</h1>
<ul>
<li>Use properties rather than a separate API.<ul>
<li>Obvious downside is that this can be a lot of code: <div class="fragment"><div class="line">function ParamTypes(...types) {</div>
<div class="line">  return (target, propertyKey) =&gt; {</div>
<div class="line">    const symParamTypes = Symbol.for(&quot;design:paramtypes&quot;);</div>
<div class="line">    if (propertyKey === undefined) {</div>
<div class="line">      target[symParamTypes] = types;</div>
<div class="line">    }</div>
<div class="line">    else {</div>
<div class="line">      const symProperties = Symbol.for(&quot;design:properties&quot;);</div>
<div class="line">      let properties, property;</div>
<div class="line">      if (Object.prototype.hasOwnProperty.call(target, symProperties)) {</div>
<div class="line">        properties = target[symProperties];</div>
<div class="line">      }</div>
<div class="line">      else {</div>
<div class="line">        properties = target[symProperties] = {};</div>
<div class="line">      }</div>
<div class="line">      if (Object.prototype.hasOwnProperty.call(properties, propertyKey)) {</div>
<div class="line">        property = properties[propertyKey];</div>
<div class="line">      }</div>
<div class="line">      else {</div>
<div class="line">        property = properties[propertyKey] = {};</div>
<div class="line">      }</div>
<div class="line">      property[symParamTypes] = types;</div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line">}</div>
</div><!-- fragment --></li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="autotoc_md11708"></a>
Notes</h1>
<ul>
<li>Though it may seem counterintuitive, the methods on Reflect place the parameters for the metadata key and metadata value before the target or property key. This is due to the fact that the property key is the only optional parameter in the argument list. This also makes the methods easier to curry with Function::bind. This also helps reduce the overall footprint and complexity of a metadata-producing decorator that could target both a class or a property:</li>
</ul>
<div class="fragment"><div class="line">function ParamTypes(...types) {</div>
<div class="line">  // as propertyKey is effectively optional, its easier to use here</div>
<div class="line">  return (target, propertyKey) =&gt; { Reflect.defineMetadata(&quot;design:paramtypes&quot;, types, target, propertyKey); }</div>
<div class="line"> </div>
<div class="line">  // vs. having multiple overloads with the target and key in the front:</div>
<div class="line">  //</div>
<div class="line">  // return (target, propertyKey) =&gt; {</div>
<div class="line">  //    if (propertyKey === undefined) {</div>
<div class="line">  //      Reflect.defineMetadata(target, &quot;design:paramtypes&quot;, types);</div>
<div class="line">  //    }</div>
<div class="line">  //    else {</div>
<div class="line">  //      Reflect.defineMetadata(target, propertyKey, &quot;design:paramtypes&quot;, types);</div>
<div class="line">  //    }</div>
<div class="line">  // }</div>
<div class="line">  //</div>
<div class="line">  // vs. having a different methods for the class or a property:</div>
<div class="line">  //</div>
<div class="line">  // return (target, propertyKey) =&gt; {</div>
<div class="line">  //    if (propertyKey === undefined) {</div>
<div class="line">  //      Reflect.defineMetadata(target, &quot;design:paramtypes&quot;, types);</div>
<div class="line">  //    }</div>
<div class="line">  //    else {</div>
<div class="line">  //      Reflect.definePropertyMetadata(target, propertyKey, &quot;design:paramtypes&quot;, types);</div>
<div class="line">  //    }</div>
<div class="line">  // }</div>
<div class="line">}</div>
</div><!-- fragment --><ul>
<li>To enable experimental support for metadata decorators in your TypeScript project, you must add <code>"experimentalDecorators": true</code> to your tsconfig.json file.</li>
<li>To enable experimental support for auto-generated type metadata in your TypeScript project, you must add <code>"emitDecoratorMetadata": true</code> to your tsconfig.json file.<ul>
<li>Please note that auto-generated type metadata may have issues with circular or forward references for types.</li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="autotoc_md11709"></a>
Issues</h1>
<ul>
<li>A poorly written mutating decorator for a class constructor could cause metadata to become lost if the prototype chain is not maintained. Though, not maintaining the prototype chain in a mutating decorator for a class constructor would have other negative side effects as well. @rbuckton<ul>
<li>This is mitigated if the mutating decorator returns a class expression that extends from the target, or returns a proxy for the decorator. @rbuckton</li>
</ul>
</li>
<li>Metadata for a method is attached to the class (or prototype) via the property key. It would not then be available if trying to read metadata on the function of the method (e.g. "tearing-off" the method from the class). @rbuckton </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
